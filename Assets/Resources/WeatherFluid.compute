#pragma kernel InjectSource
#pragma kernel AdvectVelocity
#pragma kernel AdvectScalar
#pragma kernel ComputeDivergence
#pragma kernel JacobiPressure
#pragma kernel SubtractGradient
#pragma kernel ClearTexture
#pragma kernel Visualize
#pragma kernel MoistureMicrophysics
#pragma kernel ComputeStats
#pragma kernel ApplyUpperDamping
#pragma kernel ApplyBackgroundWind
#pragma kernel InjectSynopticPressure
#pragma kernel ApplyPressureForcing
#pragma kernel ApplyCoriolis
#pragma kernel SeedThermoProfile
#pragma kernel ApplyConvergence
#pragma kernel RelaxHumidityToProfile
#pragma kernel ApplyThermalBuoyancy

// 8x8 threads cover 64 pixels per group
#define THREADS_X 8
#define THREADS_Y 8

SamplerState linearClamp
{
    Filter = MIN_MAG_LINEAR_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

cbuffer SimParams
{
    int2 _SimSize;
    float2 _InvSimSize;
    float _DeltaTime;
    float _VelocityDissipation;
    float _DensityDissipation;
    float2 _SourceCenter;
    float _SourceRadius;
    float _SourceDensity;
    float2 _SourceVelocity;
    float _SourceFeather;
    float _UnusedPadding0;
    float _UnusedPadding1;
    float _DisplayGain;
    float _DisplayGamma;
    float _SaturationThreshold;
    float _CondensationRate;
    float _EvaporationRate;
    float _PrecipitationRate;
    float _LatentHeatBuoyancy;
    float _CloudBlend;
    float _CloudGain;
    float _SourceMapBlend;
    float _UpperDampingStart;
    float _UpperDampingStrength;
    float _TemperatureSaturationFactor;
    float _LatentHeatTemperatureGain;
    float _EvaporationCoolingFactor;
    float _TurbulencePrecipFactor;
    float _TemperatureDecay;
    float _TurbulenceDecay;
    float _SourceHeat;
    float _SourceTurbulence;
    float2 _BackgroundWind;
    float _BackgroundWindStrength;
    float _PressureForceStrength;
    float _CoriolisStrength;
    float2 _PressureCenter;
    float _PressureRadius;
    float _PressureStrength;
    float _BaseTemperature;
    float _LapseRate;
    float _SurfaceHumidity;
    float _HumidityDecay;
float _ConvergenceStrength;
float _ConvergenceWidth;
float _ConvergenceHeight;
float _ConvergenceWindSpeed;
float _ConvergenceUpdraft;
    float _SurfaceHumidityRelaxStrength;
    float _SurfaceHumidityRelaxHeight;
    float _ThermalBuoyancyStrength;
    float _UnusedPad2;
};

float2 clampUV(float2 uv)
{
    float2 halfPixel = _InvSimSize * 0.5;
    return clamp(uv, halfPixel, 1.0 - halfPixel);
}

// ---------------------------------------------------------------------------
// Source injection
RWTexture2D<float2> _Velocity;
RWTexture2D<float> _Humidity;
RWTexture2D<float> _Temperature;
RWTexture2D<float> _Turbulence;
RWStructuredBuffer<float> _DebugBuffer;
Texture2D<float> _SurfaceMoistureTex;

[numthreads(THREADS_X, THREADS_Y, 1)]
void InjectSource(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float aspect = _SimSize.y > 0 ? (float)_SimSize.x / _SimSize.y : 1.0;
    float2 delta = uv - _SourceCenter;
    delta.x *= aspect;
    float dist = length(delta);
    float falloff = saturate(1.0 - smoothstep(_SourceRadius - _SourceFeather, _SourceRadius, dist));
    if (_SourceMapBlend > 0.5)
    {
        float mapSample = _SurfaceMoistureTex.SampleLevel(linearClamp, uv, 0);
        falloff *= mapSample;
    }

    if (falloff <= 0.0)
        return;

    float2 vel = _Velocity[coord];
    vel += _SourceVelocity * falloff;
    _Velocity[coord] = vel;

    float humidity = _Humidity[coord];
    humidity += _SourceDensity * falloff;
    _Humidity[coord] = humidity;

    float temp = _Temperature[coord];
    temp += _SourceHeat * falloff;
    _Temperature[coord] = temp;

    float turb = _Turbulence[coord];
    turb += _SourceTurbulence * falloff;
    _Turbulence[coord] = turb;
}

// ---------------------------------------------------------------------------
// Velocity advection
Texture2D<float2> _VectorFieldRead;
RWTexture2D<float2> _VectorFieldWrite;

[numthreads(THREADS_X, THREADS_Y, 1)]
void AdvectVelocity(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float2 vel = _VectorFieldRead.SampleLevel(linearClamp, uv, 0);
    float2 prevUV = clampUV(uv - _DeltaTime * vel);
    float2 advected = _VectorFieldRead.SampleLevel(linearClamp, prevUV, 0);
    _VectorFieldWrite[coord] = advected * _VelocityDissipation;
}

// ---------------------------------------------------------------------------
// Scalar advection (humidity / clouds)
Texture2D<float> _ScalarFieldRead;
Texture2D<float2> _ScalarVelocity;
RWTexture2D<float> _ScalarFieldWrite;

[numthreads(THREADS_X, THREADS_Y, 1)]
void AdvectScalar(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float2 vel = _ScalarVelocity.SampleLevel(linearClamp, uv, 0);
    float2 prevUV = clampUV(uv - _DeltaTime * vel);
    float sample = _ScalarFieldRead.SampleLevel(linearClamp, prevUV, 0);
    _ScalarFieldWrite[coord] = sample * _DensityDissipation;
}

// ---------------------------------------------------------------------------
// Divergence
Texture2D<float2> _VelocityField;
RWTexture2D<float> _DivergenceWrite;

float2 SampleVelocity(int2 coord)
{
    coord = clamp(coord, int2(0, 0), _SimSize - 1);
    return _VelocityField.Load(int3(coord, 0));
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void ComputeDivergence(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 left = SampleVelocity(coord + int2(-1, 0));
    float2 right = SampleVelocity(coord + int2(1, 0));
    float2 down = SampleVelocity(coord + int2(0, -1));
    float2 up = SampleVelocity(coord + int2(0, 1));

    float dx = (right.x - left.x) * 0.5;
    float dy = (up.y - down.y) * 0.5;

    _DivergenceWrite[coord] = dx + dy;
}

// ---------------------------------------------------------------------------
// Jacobi pressure solve
Texture2D<float> _PressureRead;
Texture2D<float> _DivergenceTex;
RWTexture2D<float> _PressureWrite;

float SamplePressure(Texture2D<float> tex, int2 coord)
{
    coord = clamp(coord, int2(0, 0), _SimSize - 1);
    return tex.Load(int3(coord, 0));
}

[numthreads(THREADS_X, THREADS_Y, 1)]
void JacobiPressure(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float left = SamplePressure(_PressureRead, coord + int2(-1, 0));
    float right = SamplePressure(_PressureRead, coord + int2(1, 0));
    float down = SamplePressure(_PressureRead, coord + int2(0, -1));
    float up = SamplePressure(_PressureRead, coord + int2(0, 1));
    float divergence = _DivergenceTex.Load(int3(coord, 0));

    float pressure = (left + right + down + up - divergence) * 0.25;
    _PressureWrite[coord] = pressure;
}

// ---------------------------------------------------------------------------
// Subtract gradient to obtain divergence-free velocity
Texture2D<float> _PressureTex;
RWTexture2D<float2> _VelocityWriteGradient;

[numthreads(THREADS_X, THREADS_Y, 1)]
void SubtractGradient(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float left = SamplePressure(_PressureTex, coord + int2(-1, 0));
    float right = SamplePressure(_PressureTex, coord + int2(1, 0));
    float down = SamplePressure(_PressureTex, coord + int2(0, -1));
    float up = SamplePressure(_PressureTex, coord + int2(0, 1));

    float2 vel = _VelocityWriteGradient[coord];
    vel.x -= (right - left) * 0.5;
    vel.y -= (up - down) * 0.5;
    _VelocityWriteGradient[coord] = vel;
}

// ---------------------------------------------------------------------------
// Clear helper
RWTexture2D<float> _ClearScalar;
float _ClearValue;

[numthreads(THREADS_X, THREADS_Y, 1)]
void ClearTexture(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    _ClearScalar[coord] = _ClearValue;
}

// ---------------------------------------------------------------------------
// Visualization
Texture2D<float> _DensityRead;
Texture2D<float> _CloudRead;
RWTexture2D<float4> _DisplayTexture;
float4 _ColorLow;
float4 _ColorHigh;
float4 _CloudColor;
float4 _SkyTopColor;
float4 _SkyBottomColor;
float4 _GroundColor;
float4 _CloudShadowColor;
    float _CloudShadowStrength;
    float _ShowHumidity;

[numthreads(THREADS_X, THREADS_Y, 1)]
void Visualize(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float humidity = _DensityRead.SampleLevel(linearClamp, uv, 0);
    float humidityIntensity = saturate(humidity * _DisplayGain);
    humidityIntensity = pow(humidityIntensity, max(0.1, _DisplayGamma)) * _ShowHumidity;
    float4 sky = lerp(_SkyBottomColor, _SkyTopColor, saturate(uv.y));
    float4 baseColor = lerp(_GroundColor, sky, saturate(uv.y * 1.2));
    baseColor = lerp(baseColor, _ColorHigh, humidityIntensity);

    float cloud = _CloudRead.SampleLevel(linearClamp, uv, 0);
    float cloudIntensity = saturate(cloud * _CloudGain);
    float cloudHighlight = pow(cloudIntensity, 0.6);
    float cloudLerp = saturate(cloudIntensity * _CloudBlend);
    float4 litCloud = lerp(_CloudShadowColor, _CloudColor, cloudHighlight);
    litCloud = lerp(litCloud, _CloudColor, saturate(uv.y + 0.2));
    float shadow = saturate(1.0 - (humidityIntensity * _CloudShadowStrength));
    float4 color = lerp(baseColor, litCloud, cloudLerp);
    color.rgb *= lerp(1.0, shadow, cloudLerp * 0.5);
    _DisplayTexture[coord] = color;
}

// ---------------------------------------------------------------------------
// Moisture microphysics
RWTexture2D<float> _MicroHumidity;
RWTexture2D<float> _MicroCloud;
RWTexture2D<float2> _MicroVelocity;
RWTexture2D<float> _MicroTemperature;
RWTexture2D<float> _MicroTurbulence;
RWTexture2D<float> _PrecipitationTex;

[numthreads(THREADS_X, THREADS_Y, 1)]
void MoistureMicrophysics(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float envTemp = _BaseTemperature - _LapseRate * uv.y;

    float humidity = max(0.0, _MicroHumidity[coord]);
    float cloud = max(0.0, _MicroCloud[coord]);
    float2 velocity = _MicroVelocity[coord];
    float temperature = _MicroTemperature[coord];
    float turbulence = _MicroTurbulence[coord];

    float dynamicSaturation = max(0.01, _SaturationThreshold + temperature * _TemperatureSaturationFactor);
    float supersaturation = max(0.0, humidity - dynamicSaturation);
    float condense = min(humidity, supersaturation * _CondensationRate * _DeltaTime);
    humidity -= condense;
    cloud += condense;
    temperature += condense * _LatentHeatTemperatureGain;
    turbulence += condense * 0.5;

    float humidityDeficit = max(0.0, dynamicSaturation - humidity);
    float evaporate = min(cloud, humidityDeficit * _EvaporationRate * _DeltaTime);
    cloud -= evaporate;
    humidity += evaporate;
    temperature -= evaporate * _EvaporationCoolingFactor;

    float turbulenceBoost = 1.0 + saturate(turbulence) * _TurbulencePrecipFactor;
    float precipitation = min(cloud, cloud * _PrecipitationRate * turbulenceBoost * _DeltaTime);
    cloud -= precipitation;
    _PrecipitationTex[coord] = precipitation;

    float buoyancy = condense * _LatentHeatBuoyancy;
    velocity.y += buoyancy;

    float tempDecay = saturate(1.0 - _TemperatureDecay * _DeltaTime);
    float turbDecay = saturate(1.0 - _TurbulenceDecay * _DeltaTime);
    // Relax anomalies toward the sounding instead of decaying the absolute temperature to 0.
    temperature = envTemp + (temperature - envTemp) * tempDecay;
    turbulence *= turbDecay;

    _MicroHumidity[coord] = max(0.0, humidity);
    _MicroCloud[coord] = max(0.0, cloud);
    _MicroVelocity[coord] = velocity;
    _MicroTemperature[coord] = temperature;
    _MicroTurbulence[coord] = max(0.0, turbulence);
}

// ---------------------------------------------------------------------------
// Boundary-layer humidity nudging (surface moisture reservoir)
RWTexture2D<float> _RelaxHumidity;

[numthreads(THREADS_X, THREADS_Y, 1)]
void RelaxHumidityToProfile(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    if (_SurfaceHumidityRelaxStrength <= 0.0001 || _SurfaceHumidityRelaxHeight <= 0.0001)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    if (uv.y > _SurfaceHumidityRelaxHeight)
        return;

    float target = _SurfaceHumidity * exp(-_HumidityDecay * uv.y);
    float weight = 1.0 - saturate(uv.y / max(_SurfaceHumidityRelaxHeight, 0.0001));
    float blend = saturate(_SurfaceHumidityRelaxStrength * _DeltaTime * weight);

    float humidity = max(0.0, _RelaxHumidity[coord]);
    humidity = lerp(humidity, target, blend);
    _RelaxHumidity[coord] = max(0.0, humidity);
}

// ---------------------------------------------------------------------------
// Thermal buoyancy forcing relative to the background profile.
RWTexture2D<float2> _ThermalBuoyancyVelocity;
Texture2D<float> _ThermalBuoyancyTemperature;

[numthreads(THREADS_X, THREADS_Y, 1)]
void ApplyThermalBuoyancy(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    if (abs(_ThermalBuoyancyStrength) <= 0.0001)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float envTemp = _BaseTemperature - _LapseRate * uv.y;
    float temp = _ThermalBuoyancyTemperature.Load(int3(coord.x, coord.y, 0));

    float buoy = (temp - envTemp) * _ThermalBuoyancyStrength;
    float2 vel = _ThermalBuoyancyVelocity[coord];
    vel.y += buoy * _DeltaTime;
    _ThermalBuoyancyVelocity[coord] = vel;
}

// ---------------------------------------------------------------------------
// Stats gathering (single-thread reduction)
Texture2D<float> _StatsDensityTex;
Texture2D<float2> _StatsVelocityTex;
Texture2D<float> _StatsCloudTex;
Texture2D<float> _StatsPrecipTex;

[numthreads(1, 1, 1)]
void ComputeStats(uint3 id : SV_DispatchThreadID)
{
    float densitySum = 0.0;
    float densityMax = 0.0;
    float speedSum = 0.0;
    float speedMax = 0.0;
    float cloudSum = 0.0;
    float cloudMax = 0.0;
    float precipSum = 0.0;
    float precipMax = 0.0;

    for (int y = 0; y < _SimSize.y; ++y)
    {
        for (int x = 0; x < _SimSize.x; ++x)
        {
            float cellHumidity = _StatsDensityTex.Load(int3(x, y, 0));
            densitySum += cellHumidity;
            densityMax = max(densityMax, cellHumidity);

            float cloud = _StatsCloudTex.Load(int3(x, y, 0));
            cloudSum += cloud;
            cloudMax = max(cloudMax, cloud);

            float precip = _StatsPrecipTex.Load(int3(x, y, 0));
            precipSum += precip;
            precipMax = max(precipMax, precip);

            float2 vel = _StatsVelocityTex.Load(int3(x, y, 0));
            float speed = length(vel);
            speedSum += speed;
            speedMax = max(speedMax, speed);
        }
    }

    float cellCount = float(_SimSize.x * _SimSize.y);
    float avgDensity = densitySum / max(cellCount, 1.0);
    float avgSpeed = speedSum / max(cellCount, 1.0);
    float avgCloud = cloudSum / max(cellCount, 1.0);
    float avgPrecip = precipSum / max(cellCount, 1.0);

    _DebugBuffer[0] = avgDensity;
    _DebugBuffer[1] = densityMax;
    _DebugBuffer[2] = avgSpeed;
    _DebugBuffer[3] = speedMax;
    _DebugBuffer[4] = avgCloud;
    _DebugBuffer[5] = cloudMax;
    _DebugBuffer[6] = densitySum + cloudSum;
    _DebugBuffer[7] = cellCount;
    _DebugBuffer[8] = avgPrecip;
    _DebugBuffer[9] = precipMax;
    _DebugBuffer[10] = precipSum;
    _DebugBuffer[11] = 0.0;
}
RWTexture2D<float2> _VelocityDamp;
// ---------------------------------------------------------------------------
// Upper-layer damping to keep flow within view
[numthreads(THREADS_X, THREADS_Y, 1)]
void ApplyUpperDamping(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    if (_UpperDampingStrength <= 0.0001 || _UpperDampingStart >= 0.9999)
        return;

    float t = saturate((uv.y - _UpperDampingStart) / max(0.0001, 1.0 - _UpperDampingStart));
    float damp = lerp(1.0, 1.0 - saturate(_UpperDampingStrength), t);
    float2 vel = _VelocityDamp[coord];
    _VelocityDamp[coord] = vel * damp;
}

// ---------------------------------------------------------------------------
// Background wind relaxation
RWTexture2D<float2> _BackgroundWindVelocity;

[numthreads(THREADS_X, THREADS_Y, 1)]
void ApplyBackgroundWind(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float blend = saturate(_BackgroundWindStrength * _DeltaTime);
    if (blend <= 0.0)
        return;

    float2 vel = _BackgroundWindVelocity[coord];
    _BackgroundWindVelocity[coord] = lerp(vel, _BackgroundWind, blend);
}

// ---------------------------------------------------------------------------
// Synoptic pressure injection (for storm centers)
RWTexture2D<float> _SynopticPressureWrite;

[numthreads(THREADS_X, THREADS_Y, 1)]
void InjectSynopticPressure(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float aspect = _SimSize.y > 0 ? (float)_SimSize.x / _SimSize.y : 1.0;
    float2 delta = uv - _PressureCenter;
    delta.x *= aspect;
    float dist = length(delta);
    float sigma = max(0.0001, _PressureRadius);
    float falloff = exp(-0.5 * (dist * dist) / (sigma * sigma));
    _SynopticPressureWrite[coord] += _PressureStrength * falloff;
}

// ---------------------------------------------------------------------------
// Pressure-gradient forcing
Texture2D<float> _PressureForceTex;
RWTexture2D<float2> _PressureForceVelocity;

[numthreads(THREADS_X, THREADS_Y, 1)]
void ApplyPressureForcing(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    if (_PressureForceStrength <= 0.0001)
        return;

    float left = _PressureForceTex.Load(int3(max(coord.x - 1, 0), coord.y, 0));
    float right = _PressureForceTex.Load(int3(min(coord.x + 1, _SimSize.x - 1), coord.y, 0));
    float down = _PressureForceTex.Load(int3(coord.x, max(coord.y - 1, 0), 0));
    float up = _PressureForceTex.Load(int3(coord.x, min(coord.y + 1, _SimSize.y - 1), 0));
    float2 grad = float2(right - left, up - down) * 0.5;

    float2 vel = _PressureForceVelocity[coord];
    vel += (-grad) * (_PressureForceStrength * _DeltaTime);
    _PressureForceVelocity[coord] = vel;
}

// ---------------------------------------------------------------------------
// Coriolis-like turning
RWTexture2D<float2> _CoriolisVelocity;

[numthreads(THREADS_X, THREADS_Y, 1)]
void ApplyCoriolis(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    if (abs(_CoriolisStrength) <= 0.0001)
        return;

    float2 vel = _CoriolisVelocity[coord];
    float2 perp = float2(-vel.y, vel.x);
    vel += perp * (_CoriolisStrength * _DeltaTime);
    _CoriolisVelocity[coord] = vel;
}

// ---------------------------------------------------------------------------
// Thermodynamic profile seeding
RWTexture2D<float> _SeedTemperatureA;
RWTexture2D<float> _SeedTemperatureB;
RWTexture2D<float> _SeedHumidityA;
RWTexture2D<float> _SeedHumidityB;

[numthreads(THREADS_X, THREADS_Y, 1)]
void SeedThermoProfile(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float temperature = _BaseTemperature - _LapseRate * uv.y;
    float humidity = _SurfaceHumidity * exp(-_HumidityDecay * uv.y);

    _SeedTemperatureA[coord] = temperature;
    _SeedTemperatureB[coord] = temperature;
    _SeedHumidityA[coord] = humidity;
    _SeedHumidityB[coord] = humidity;
}

// ---------------------------------------------------------------------------
// Low-level convergence forcing
RWTexture2D<float2> _ConvergenceVelocity;

[numthreads(THREADS_X, THREADS_Y, 1)]
void ApplyConvergence(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int2 coord = int2(dispatchThreadID.xy);
    if (coord.x >= _SimSize.x || coord.y >= _SimSize.y)
        return;

    if (_ConvergenceStrength <= 0.0001)
        return;

    float2 uv = (float2(coord) + 0.5) * _InvSimSize;
    float heightFalloff = 1.0 - smoothstep(_ConvergenceHeight, _ConvergenceHeight + 0.1, uv.y);
    if (heightFalloff <= 0.0)
        return;

    float dist = abs(uv.x - 0.5);
    float band = 1.0 - smoothstep(_ConvergenceWidth, _ConvergenceWidth * 1.5, dist);
    if (band <= 0.0)
        return;

    float targetX = (uv.x < 0.5 ? 1.0 : -1.0) * _ConvergenceWindSpeed;
    float blend = saturate(_ConvergenceStrength * _DeltaTime * heightFalloff * band);

    float2 vel = _ConvergenceVelocity[coord];
    float newX = lerp(vel.x, targetX, blend);
    float newY = lerp(vel.y, _ConvergenceUpdraft, blend);
    _ConvergenceVelocity[coord] = float2(newX, newY);
}
